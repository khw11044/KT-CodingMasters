'''
제임스는 외부의 침략으로부터 마을을 지킬 수 있는 부메랑 무기를 개발하는 무기 공학자입니다. 
제임스는 자신의 동료인 토마스로부터 최고급 나무 재료를 구했습니다.
이 나무 재료는 N X M 크기의 넓은 사각형 형태이며 나무 재료의 부위마다 그 강도가 조금씩 다릅니다.

예를 들어 나무 재료의 크기가 2 X 3일 때는 다음과 같이 총 6칸으로 구성되며,
각 위치마다 작게는 1부터 크게는 100까지의 강도를 가지게 됩니다.

7 5 4
3 2 9

제임스는 이처럼 넓은 사각형 형태의 나무 재료를 잘라서 여러 개의 부메랑을 만들고자 합니다.
부메랑은 항상 3칸을 차지하는 ㄱ 모양으로 만들어야 합니다. 
(회전을 시킬 수 있으므로 부메랑의 가능한 모양은 총 4가지가 됩니다.) 
이 때 부메랑의 중심이 되는 칸은 강도의 영향을 2배로 받습니다.

예를 들어 위 예시에서 다음과 같은 부메랑 하나를 만들었다고 가정합니다.

7 5
3

이 때 부메랑의 총 강도는 7 * 2 + 5 + 3 = 22가 됩니다. 
결과적으로 위 예시에서는 총 2개의 부메랑을 만들 수 있으며 이 때 가능한 총 최대 강도는 46입니다.

나무 재료의 형태와 각 위치의 강도가 주어졌을 때,
제임스가 만들 수 있는 부메랑들의 강도의 합의 최댓값을 출력하는 프로그램을 작성하세요.
------------------------------------------------------------------------
[입력값 설명]
『첫 번째 줄에는 제임스가 가지고 있는 나무 재료의 세로, 가로 크기를 의미하는
두 자연수 N, M이 공백으로 구분되어 주어집니다. (1 ≤ N, M ≤ 5)
다음 N개의 줄에 나무 재료의 강도를 나타내는 M개의 자연수 K가 공백으로 구분되어 주어집니다. (1 ≤ K ≤ 100)』

[출력값 설명]
『첫 번째 줄에 제임스가 만들 수 있는 부메랑들의 강도의 합의 최댓값을 출력합니다.
단, 나무 재료의 크기가 작아서 부메랑을 만들 수 없는 경우는 0을 출력합니다.』
------------------------------------------------------------------------
예제 입력1
2 3
7 5 4
3 2 9

예제 출력1
46

예제 입력2
3 3
32 83 75
24 96 56
71 88 12

예제 출력2
632

테스트 입력
5 5
1 2 3 4 5
2 3 4 5 6
3 4 5 6 7
4 5 6 7 8
5 6 7 8 9

테스트 출력
164
'''
import sys
input = sys.stdin.readline

def unmake(mold, y, x):
    for i in range(2):
        for j in range(2):
            if mold[i][j] > 0:
                used[y+i][x+j] = False

def make(mold, y, x):
    s = 0
    for i in range(2):
        for j in range(2):
            if mold[i][j] > 0:
                s += mold[i][j]*K[y+i][x+j]
                used[y+i][x+j] = True
    return s

def is_make(mold, y, x):
    c = 0
    for i in range(2):
        for j in range(2):
            if ((mold[i][j] > 0) & (used[y+i][x+j]==False)): c += 1
    if c == 3: return True
    else: return False

def DFS(sum, y, x):
    global answer
    if x == M-1:
        x = 0
        y += 1
    if y == N-1:
        answer = max(answer, sum)
        return

    for mold in molds:
        if is_make(mold, y, x):
            DFS(sum + make(mold, y, x), y, x+1)
            unmake(mold, y, x)
    DFS(sum, y, x+1)

if __name__ == "__main__":
    N, M = map(int, input().split())
    K = [list(map(int, input().split())) for _ in range(N)]
    used = [[False] * M for _ in range(N)]
    molds = [((2, 1), (1, 0)), ((1, 2), (0, 1)), ((0, 1), (1, 2)), ((1, 0), (2, 1))]

    answer = 0
    if ((N > 1) & (M > 1)):
        DFS(0, 0, 0)
    else:
        answer = 0
    print(answer)