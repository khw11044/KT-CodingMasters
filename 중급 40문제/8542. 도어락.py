'''
재승의 집은 3행 3열의 버튼이 있는 도어락이 설치되어 있습니다.
재승은 완벽하며 매사에 최선을 다하기 때문에,
비밀번호를 입력할 때 절대 틀리지 않으며 버튼도 최대한 빠르게 누릅니다. 

재승이 버튼을 최대한 빠르게 누를 때, 
누르려는 버튼과 방금 누른 버튼의 상대적 위치에 따라 걸리는 시간은 다음과 같습니다.

- 같은 버튼인 경우 1 ms
- 한 변 또는 모서리를 공유하는 경우 2 ms
- 그 밖의 경우 3 ms

버튼을 누르면 ‘삑’ 하는 버튼 입력음이 납니다. 
착한 친구 승재는 “내 계산 결과 네 비밀번호의 경우의 수는 X가지밖에 안 돼. 더 강력한 비밀번호로 바꾸지 않을래?”라고 조언하려 합니다.

승재는 타고난 리듬감으로 재승이 각 버튼을 누르는데 걸린 시간을 완벽하게 기록했습니다.
하지만 경우의 수를 어떻게 계산해야 할지 몰라 당황하고 있습니다. 
승재를 도와 경우의 수를 출력해주는 프로그램을 작성하세요.

-------------------------------------------
[입력값 설명]
첫번째 줄에 비밀번호의 길이 N이 주어집니다. (2 ≤ N ≤ 200)

두번째 줄에 N-1개의 수가 공백을 구분으로 주어집니다.
앞에서부터 순서대로 2번 버튼을 누르는데 걸린 시간, 3번 버튼을 누르는데 걸린 시간, …, N번 버튼을 누르는데 걸린 시간입니다.

[출력값 설명]
재승이의 비밀번호의 경우의 수를 1,000,000,007 으로 나누어 출력합니다.
--------------------------------------------------

예제 입력1
5
1 1 1 1

예제 출력1
9

예제 입력2
2
2

예제 출력2
40

예제 입력3
2
3

예제 출력3
32

예제 입력4
3
2 2

예제 출력2
200

--------------------------------------------------
예제 1 설명
5
1 1 1 1
처음 1 선택 -> (1초 걸리는건 1밖에 없으니) 두번 째 1 선택 -> .. -> 마지막 1 선택 (비밀번호 1 1 1 1 1)
처음 2 선택 -> (1초 걸리는건 2밖에 없으니) 두번 째 2 선택 -> .. -> 마지막 2 선택 (비밀번호 2 2 2 2 2)
처음 3 선택 -> (1초 걸리는건 3밖에 없으니) 두번 째 3 선택 -> .. -> 마지막 3 선택 (비밀번호 3 3 3 3 3)
.
.
.
처음 9 선택 -> (1초 걸리는건 9밖에 없으니) 두번 째 9 선택 -> .. -> 마지막 9 선택 (비밀번호 9 9 9 9 9)
총 9가지

예제 2 설명
2
2
1 선택 -> 2ms걸리는 (2, 4, 5) : 3가지  
2 선택 -> 2ms걸리는 (1, 3, 4, 5, 6) : 5가지 
3 선택 -> 2ms걸리는 (2, 5, 6) : 3가지 
4 선택 -> 2ms걸리는 (1, 2, 5, 7, 8) : 5가지 
5 선택 -> 2ms걸리는 (1, 2, 3, 4, 6, 7, 8, 9) : 8가지
6 선택 -> 2ms걸리는 (2, 3, 5, 8, 9) : 5가지 
7 선택 -> 2ms걸리는 (4, 5, 8) : 3가지 
8 선택 -> 2ms걸리는 (4, 5, 6, 7, 9) : 5가지 
9 선택 -> 2ms걸리는 (5, 6, 8) : 3가지
총 40가지 

예제 3설명 
2
3
1 선택 -> (1, 2, 4, 5)이 아닌 수들 : 9-1-3=5가지  
2 선택 -> (2, 1, 3, 4, 5, 6)이 아닌 수들: 9-1-5=3가지 
3 선택 -> (3, 2, 5, 6)이 아닌 수들 : 9-1-3=5가지 
4 선택 -> (4, 1, 2, 5, 7, 8)이 아닌 수들 : 9-1-5=3가지 
5 선택 -> (5, 1, 2, 3, 4, 6, 7, 8, 9) : 9-1-8=0가지
6 선택 -> (6, 2, 3, 5, 8, 9) : 9-1-5=3가지 
7 선택 -> (7, 4, 5, 8) : 9-1-3=5가지 
8 선택 -> (8, 4, 5, 6, 7, 9) : 9-1-5=3가지 
9 선택 -> (9, 5, 6, 8) : 9-1-3=5가지
총 32가지 

예제 4 설명
3
2 2
1 선택 -> 2ms 걸리는 2, 4, 5 선택 가능 -> (2 선택한경우: 5가지), (4 선택한경우: 5가지), (5 선택한경우: 8가지) = 13가지 
2 선택 -> 2ms걸리는 1, 3, 4, 5, 6 선택 가능 -> (1 선택한경우: 3가지), (3 선택한경우: 3가지), (4 선택한경우: 5가지), (5 선택한경우: 8가지), (6 선택한경우: 5가지) : 24가지  
3 선택 -> 2ms걸리는 2, 5, 6 선택 가능 -> 5가지+8가지+5가지 = 18가지
4 선택 -> 2ms걸리는 1, 2, 5, 7, 8 -> 3가지+5가지+8가지+3가지+5가지 = 24가지
5 선택 -> 2ms걸리는 1, 2, 3, 4, 6, 7, 8, 9 -> 3+5+3+5+5+3+5+3 = 32가지  
6 선택 -> 2ms걸리는 2, 3, 5, 8, 9 -> 5+3+8+5+3 = 24가지
7 선택 -> 2ms걸리는 4, 5, 8 -> 5+8+5 = 18가지
8 선택 -> 2ms걸리는 4, 5, 6, 7, 9 -> 5+8+5+3+3 = 24가지 
9 선택 -> 2ms걸리는 5, 6, 8 -> 8+5+5 = 18가지
총 200가지

'''

# 8542. 도어락
import sys
# sys.stdin=open('input.txt', 'r')


def Password(N, times):
    MOD = 1_000_000_007
    # Define the adjacency for each button in a 3x3 grid
    adjacency = {
        1: [2, 4, 5],
        2: [1, 3, 4, 5, 6],
        3: [2, 5, 6],
        4: [1, 2, 5, 7, 8],
        5: [1, 2, 3, 4, 6, 7, 8, 9],
        6: [2, 3, 5, 8, 9],
        7: [4, 5, 8],
        8: [4, 5, 6, 7, 9],
        9: [5, 6, 8],
    }
    non_adjacency = {k: [n for n in range(1, 10) if n not in v and n != k] for k, v in adjacency.items()}

    # Initialize the possibilities for each button
    dp = [[0] * 10 for _ in range(N + 1)]  # dp[i][j] is the number of ways to end at button j on step i
    for j in range(1, 10):
        dp[1][j] = 1

    for i in range(2, N + 1):
        for j in range(1, 10):
            if times[i - 2] == 1:
                dp[i][j] = dp[i - 1][j]
            elif times[i - 2] == 2:
                dp[i][j] = sum(dp[i - 1][k] for k in adjacency[j])
            elif times[i - 2] == 3:
                dp[i][j] = sum(dp[i - 1][k] for k in non_adjacency[j])

    return sum(dp[N]) % MOD

if __name__ == "__main__":
    N=int(input())
    times = list(map(int, input().split()))
    
    print(Password(N, times))
    
    # MOD = 1_000_000_007
    # dp = [[0]*10]*4
    # dp[1] = [0,1,1,1,1,1,1,1,1,1]       # 첫번째 번호 선택 이후 1초 걸리는 경우 
    # dp[2] = [0,3,5,3,5,8,5,3,5,3]       # 첫번재 번호 선택 이후 2초 걸리는 경우 
    # dp[3] = [0,5,3,5,3,0,3,5,3,5]       # 첫번째 번호 선택 이후 3초 걸리는 경우 
    
    # nums = [
    #     [1,2,3],
    #     [4,5,6],
    #     [7,8,9]
    # ]
    
    # for t in times:
    #     for i in range(3):
    #         for j in range(3):
    #             dp[t][nums[i][j]]
            
            
        

    